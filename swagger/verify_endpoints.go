package swagger

// This file is autogenerated. DO NOT EDIT

import (
	"encoding/json"
	"fmt"
	"strings"
)

///////////////

type resultGetAddress struct {
	Ok     bool `json:"ok"`
	Result struct {
		Address     string `json:"address"`
		Type        string `json:"type"`
		AddressBook struct {
			Id      uint64 `json:"id"`
			Name    string `json:"name"`
			Address string `json:"address"`
			Comment string `json:"comment"`
		} `json:"addressBook"`
		Balance struct {
			String string `json:"string"`
		} `json:"balance"`
		BalanceNft []struct {
			NftId      string `json:"nftId"`
			Amount     string `json:"amount"`
			Collection string `json:"collection"`
		} `json:"balanceNft"`
		Nonce        uint64 `json:"nonce"`
		Txes         uint64 `json:"txes"`
		StakeBalance struct {
			String string `json:"string"`
		} `json:"stakeBalance"`
		UnbondBalance struct {
			String string `json:"string"`
		} `json:"unbondBalance"`
		GeneratedWallets []uint64 `json:"generatedWallets"`
		EvmAccountInfo   struct {
			Address                      string `json:"address"`
			EvmAccountERC20TokenBalances []struct {
				Amount         string `json:"amount"`
				EvmTokenSchema struct {
					Address string `json:"address"`
					Symbol  string `json:"symbol"`
					Title   string `json:"title"`
				} `json:"evmTokenSchema"`
			} `json:"evmAccountERC20TokenBalances"`
			EvmAccountERC721TokenBalances []struct {
				Amount         string `json:"amount"`
				TokenId        string `json:"tokenId"`
				EvmTokenSchema struct {
					Address string `json:"address"`
					Symbol  string `json:"symbol"`
					Title   string `json:"title"`
				} `json:"evmTokenSchema"`
			} `json:"evmAccountERC721TokenBalances"`
			EvmAccountERC1155TokenBalances []struct {
				Amount         string `json:"amount"`
				TokenId        string `json:"tokenId"`
				EvmTokenSchema struct {
					Address string `json:"address"`
					Symbol  string `json:"symbol"`
					Title   string `json:"title"`
				} `json:"evmTokenSchema"`
			} `json:"evmAccountERC1155TokenBalances"`
		} `json:"evmAccountInfo"`
	} `json:"result"`
}

// /address/{id}
// Get address by id
func (api *API) VerificationGetAddress(id string) ([]string, error) {

	var r = strings.NewReplacer(
		"{id}", fmt.Sprintf("%s", id),
	)
	var link = r.Replace("/address/{id}")

	// request
	res, err := api.client.R().Get(link)
	if err != nil {
		return nil, err
	}
	if res.StatusCode() != 200 {
		return nil, fmt.Errorf("status: %d", res.StatusCode())
	}

	// json decode
	respValue := resultGetAddress{}
	err = json.Unmarshal(res.Body(), &respValue)
	if err != nil {
		return nil, err
	}
	// process result
	bz, _ := json.Marshal(respValue)
	if err != nil {
		return nil, err
	}

	result := []string{fmt.Sprintf("url: %s", link)}
	result = append(result, compareJSON(bz, res.Body())...)
	return result, nil
}

///////////////

type resultGetNFTCollection struct {
	Ok     bool        `json:"ok"`
	Result interface{} `json:"result"`
}

// /nft/{collection}
// Get nft collection
func (api *API) VerificationGetNFTCollection(collection string) ([]string, error) {

	var r = strings.NewReplacer(
		"{collection}", fmt.Sprintf("%s", collection),
	)
	var link = r.Replace("/nft/{collection}")

	// request
	res, err := api.client.R().Get(link)
	if err != nil {
		return nil, err
	}
	if res.StatusCode() != 200 {
		return nil, fmt.Errorf("status: %d", res.StatusCode())
	}

	// json decode
	respValue := resultGetNFTCollection{}
	err = json.Unmarshal(res.Body(), &respValue)
	if err != nil {
		return nil, err
	}
	// process result
	bz, _ := json.Marshal(respValue)
	if err != nil {
		return nil, err
	}

	result := []string{fmt.Sprintf("url: %s", link)}
	result = append(result, compareJSON(bz, res.Body())...)
	return result, nil
}

///////////////

type resultGetNFTTransactions struct {
	Ok     bool `json:"ok"`
	Result struct {
		Count int64 `json:"count"`
		Txs   []struct {
			Hash      string `json:"hash"`
			Timestamp string `json:"timestamp"`
			Status    string `json:"status"`
			Type      string `json:"type"`
			Fee       struct {
				Data struct {
					Gas_coin        string `json:"gas_coin"`
					Gas_used        string `json:"gas_used"`
					Gas_amount      string `json:"gas_amount"`
					Gas_used_number uint64 `json:"gas_used_number"`
				} `json:"data"`
			} `json:"fee"`
			Data struct {
				Coin               string `json:"coin"`
				Amount             string `json:"amount"`
				Issuer             string `json:"issuer"`
				Sender             string `json:"sender"`
				EvmDataTransaction struct {
					Coin      string `json:"coin"`
					Amount    string `json:"amount"`
					Sender    string `json:"sender"`
					Recipient string `json:"recipient"`
				} `json:"evmDataTransaction"`
			} `json:"data"`
			Nonce              uint64 `json:"nonce"`
			Code               uint64 `json:"code"`
			BlockId            uint64 `json:"blockId"`
			Message            string `json:"message"`
			From               uint64 `json:"from"`
			To                 uint64 `json:"to"`
			MultisendReceivers []struct {
				Address string `json:"address"`
				Amount  string `json:"amount"`
				Coin    string `json:"coin"`
			} `json:"multisendReceivers"`
			Sender struct {
				Address string `json:"address"`
			} `json:"sender"`
			Recipient struct {
				Address string `json:"address"`
			} `json:"recipient"`
		} `json:"txs"`
	} `json:"result"`
}

// /nft/{collection}/{id}/txs
// Get nft's transactions
func (api *API) VerificationGetNFTTransactions(collection string, id string, opt *OptionalParams) ([]string, error) {

	var r = strings.NewReplacer(
		"{collection}", fmt.Sprintf("%s", collection),
		"{id}", fmt.Sprintf("%s", id),
	)
	var link = r.Replace("/nft/{collection}/{id}/txs")
	if opt != nil {
		link += opt.String()
	}

	// request
	res, err := api.client.R().Get(link)
	if err != nil {
		return nil, err
	}
	if res.StatusCode() != 200 {
		return nil, fmt.Errorf("status: %d", res.StatusCode())
	}

	// json decode
	respValue := resultGetNFTTransactions{}
	err = json.Unmarshal(res.Body(), &respValue)
	if err != nil {
		return nil, err
	}
	// process result
	bz, _ := json.Marshal(respValue)
	if err != nil {
		return nil, err
	}

	result := []string{fmt.Sprintf("url: %s", link)}
	result = append(result, compareJSON(bz, res.Body())...)
	return result, nil
}

///////////////

type resultGetTx struct {
	Ok     bool `json:"ok"`
	Result struct {
		Hash      string `json:"hash"`
		Timestamp string `json:"timestamp"`
		Status    string `json:"status"`
		Type      string `json:"type"`
		Fee       struct {
			Data struct {
				Gas_coin        string `json:"gas_coin"`
				Gas_used        string `json:"gas_used"`
				Gas_amount      string `json:"gas_amount"`
				Gas_used_number uint64 `json:"gas_used_number"`
			} `json:"data"`
		} `json:"fee"`
		Data struct {
			Coin               string `json:"coin"`
			Amount             string `json:"amount"`
			Issuer             string `json:"issuer"`
			Sender             string `json:"sender"`
			EvmDataTransaction struct {
				Coin      string `json:"coin"`
				Amount    string `json:"amount"`
				Sender    string `json:"sender"`
				Recipient string `json:"recipient"`
			} `json:"evmDataTransaction"`
		} `json:"data"`
		Nonce              uint64 `json:"nonce"`
		Code               uint64 `json:"code"`
		BlockId            uint64 `json:"blockId"`
		Message            string `json:"message"`
		From               uint64 `json:"from"`
		To                 uint64 `json:"to"`
		MultisendReceivers []struct {
			Address string `json:"address"`
			Amount  string `json:"amount"`
			Coin    string `json:"coin"`
		} `json:"multisendReceivers"`
		Sender struct {
			Address string `json:"address"`
		} `json:"sender"`
		Recipient struct {
			Address string `json:"address"`
		} `json:"recipient"`
	} `json:"result"`
}

// /tx/{hash}
// Get transaction by hash data
func (api *API) VerificationGetTxByHash(hash string) ([]string, error) {

	var r = strings.NewReplacer(
		"{hash}", fmt.Sprintf("%s", hash),
	)
	var link = r.Replace("/tx/{hash}")

	// request
	res, err := api.client.R().Get(link)
	if err != nil {
		return nil, err
	}
	if res.StatusCode() != 200 {
		return nil, fmt.Errorf("status: %d", res.StatusCode())
	}

	// json decode
	respValue := resultGetTx{}
	err = json.Unmarshal(res.Body(), &respValue)
	if err != nil {
		return nil, err
	}
	// process result
	bz, _ := json.Marshal(respValue)
	if err != nil {
		return nil, err
	}

	result := []string{fmt.Sprintf("url: %s", link)}
	result = append(result, compareJSON(bz, res.Body())...)
	return result, nil
}

///////////////

type resultGetTxs struct {
	Ok     bool `json:"ok"`
	Result struct {
		Count int64 `json:"count"`
		Txs   []struct {
			Hash      string `json:"hash"`
			Timestamp string `json:"timestamp"`
			Status    string `json:"status"`
			Type      string `json:"type"`
			Fee       struct {
				Data struct {
					Gas_coin        string `json:"gas_coin"`
					Gas_used        string `json:"gas_used"`
					Gas_amount      string `json:"gas_amount"`
					Gas_used_number uint64 `json:"gas_used_number"`
				} `json:"data"`
			} `json:"fee"`
			Data struct {
				Coin               string `json:"coin"`
				Amount             string `json:"amount"`
				Issuer             string `json:"issuer"`
				Sender             string `json:"sender"`
				EvmDataTransaction struct {
					Coin      string `json:"coin"`
					Amount    string `json:"amount"`
					Sender    string `json:"sender"`
					Recipient string `json:"recipient"`
				} `json:"evmDataTransaction"`
			} `json:"data"`
			Nonce              uint64 `json:"nonce"`
			Code               uint64 `json:"code"`
			BlockId            uint64 `json:"blockId"`
			Message            string `json:"message"`
			From               uint64 `json:"from"`
			To                 uint64 `json:"to"`
			MultisendReceivers []struct {
				Address string `json:"address"`
				Amount  string `json:"amount"`
				Coin    string `json:"coin"`
			} `json:"multisendReceivers"`
			Sender struct {
				Address string `json:"address"`
			} `json:"sender"`
			Recipient struct {
				Address string `json:"address"`
			} `json:"recipient"`
		} `json:"txs"`
	} `json:"result"`
}

// /txs
// Get all transactions
func (api *API) VerificationGetTxs(opt *OptionalParams) ([]string, error) {

	var link = "/txs"
	if opt != nil {
		link += opt.String()
	}

	// request
	res, err := api.client.R().Get(link)
	if err != nil {
		return nil, err
	}
	if res.StatusCode() != 200 {
		return nil, fmt.Errorf("status: %d", res.StatusCode())
	}

	// json decode
	respValue := resultGetTxs{}
	err = json.Unmarshal(res.Body(), &respValue)
	if err != nil {
		return nil, err
	}
	// process result
	bz, _ := json.Marshal(respValue)
	if err != nil {
		return nil, err
	}

	result := []string{fmt.Sprintf("url: %s", link)}
	result = append(result, compareJSON(bz, res.Body())...)
	return result, nil
}

///////////////

type resultGetCoins struct {
	Ok     bool `json:"ok"`
	Result struct {
		Count        uint64 `json:"count"`
		TotalReserve string `json:"totalReserve"`
		Coins        []struct {
			Symbol          string `json:"symbol"`
			Title           string `json:"title"`
			Volume          string `json:"volume"`
			Reserve         string `json:"reserve"`
			Crr             uint64 `json:"crr"`
			LimitVolume     string `json:"limitVolume"`
			PriceUSD        string `json:"priceUSD"`
			Creator         string `json:"creator"`
			TxHash          string `json:"txHash"`
			BlockId         uint64 `json:"blockId"`
			Avatar          string `json:"avatar"`
			ContractAddress string `json:"contractAddress"`
			Burn            string `json:"burn"`
			Price           string `json:"price"`
			ReserveUSD      string `json:"reserveUSD"`
			Delegated       string `json:"delegated"`
		} `json:"coins"`
	} `json:"result"`
}

// /coins
// Get all coins
func (api *API) VerificationGetCoins(opt *OptionalParams) ([]string, error) {

	var link = "/coins"
	if opt != nil {
		link += opt.String()
	}

	// request
	res, err := api.client.R().Get(link)
	if err != nil {
		return nil, err
	}
	if res.StatusCode() != 200 {
		return nil, fmt.Errorf("status: %d", res.StatusCode())
	}

	// json decode
	respValue := resultGetCoins{}
	err = json.Unmarshal(res.Body(), &respValue)
	if err != nil {
		return nil, err
	}
	// process result
	bz, _ := json.Marshal(respValue)
	if err != nil {
		return nil, err
	}

	result := []string{fmt.Sprintf("url: %s", link)}
	result = append(result, compareJSON(bz, res.Body())...)
	return result, nil
}

///////////////

type resultGetCoin struct {
	Ok     bool        `json:"ok"`
	Result interface{} `json:"result"`
}

// /coin/{coin}
// Get coin
func (api *API) VerificationGetCoin(coin string) ([]string, error) {

	var r = strings.NewReplacer(
		"{coin}", fmt.Sprintf("%s", coin),
	)
	var link = r.Replace("/coin/{coin}")

	// request
	res, err := api.client.R().Get(link)
	if err != nil {
		return nil, err
	}
	if res.StatusCode() != 200 {
		return nil, fmt.Errorf("status: %d", res.StatusCode())
	}

	// json decode
	respValue := resultGetCoin{}
	err = json.Unmarshal(res.Body(), &respValue)
	if err != nil {
		return nil, err
	}
	// process result
	bz, _ := json.Marshal(respValue)
	if err != nil {
		return nil, err
	}

	result := []string{fmt.Sprintf("url: %s", link)}
	result = append(result, compareJSON(bz, res.Body())...)
	return result, nil
}

///////////////

type resultGetBlocks struct {
	Ok     bool `json:"ok"`
	Result struct {
		Count  uint64 `json:"count"`
		Blocks []struct {
			Height          uint64 `json:"height"`
			Date            string `json:"date"`
			Hash            string `json:"hash"`
			Size            uint64 `json:"size"`
			Reward          uint64 `json:"reward"`
			BlockTime       uint64 `json:"blockTime"`
			TxsCount        uint64 `json:"txsCount"`
			ValidatorsCount uint64 `json:"validatorsCount"`
			ProposerId      string `json:"proposerId"`
			CreatedAt       string `json:"createdAt"`
		} `json:"blocks"`
	} `json:"result"`
}

// /blocks
// Get all blocks
func (api *API) VerificationGetBlocks(opt *OptionalParams) ([]string, error) {

	var link = "/blocks"
	if opt != nil {
		link += opt.String()
	}

	// request
	res, err := api.client.R().Get(link)
	if err != nil {
		return nil, err
	}
	if res.StatusCode() != 200 {
		return nil, fmt.Errorf("status: %d", res.StatusCode())
	}

	// json decode
	respValue := resultGetBlocks{}
	err = json.Unmarshal(res.Body(), &respValue)
	if err != nil {
		return nil, err
	}
	// process result
	bz, _ := json.Marshal(respValue)
	if err != nil {
		return nil, err
	}

	result := []string{fmt.Sprintf("url: %s", link)}
	result = append(result, compareJSON(bz, res.Body())...)
	return result, nil
}

///////////////

type resultGetBlock struct {
	Ok     bool `json:"ok"`
	Result struct {
		Height          uint64 `json:"height"`
		Date            string `json:"date"`
		Hash            string `json:"hash"`
		Size            uint64 `json:"size"`
		Reward          uint64 `json:"reward"`
		BlockTime       uint64 `json:"blockTime"`
		TxsCount        uint64 `json:"txsCount"`
		ValidatorsCount uint64 `json:"validatorsCount"`
		ProposerId      string `json:"proposerId"`
		CreatedAt       string `json:"createdAt"`
		EvmBlock        struct {
			Height            uint64      `json:"height"`
			Hash              string      `json:"hash"`
			Date              string      `json:"date"`
			Miner             string      `json:"miner"`
			BaseFeePerGas     uint64      `json:"baseFeePerGas"`
			GasUsed           uint64      `json:"gasUsed"`
			GasLimit          uint64      `json:"gasLimit"`
			Data              interface{} `json:"data"`
			TransactionsCount uint64      `json:"transactionsCount"`
			ReceiptsCount     uint64      `json:"receiptsCount"`
			CreatedAt         string      `json:"createdAt"`
		} `json:"evmBlock"`
	} `json:"result"`
}

// /block/{height}
// Get block by id
func (api *API) VerificationGetBlockByHeight(height uint64) ([]string, error) {

	var r = strings.NewReplacer(
		"{height}", fmt.Sprintf("%d", height),
	)
	var link = r.Replace("/block/{height}")

	// request
	res, err := api.client.R().Get(link)
	if err != nil {
		return nil, err
	}
	if res.StatusCode() != 200 {
		return nil, fmt.Errorf("status: %d", res.StatusCode())
	}

	// json decode
	respValue := resultGetBlock{}
	err = json.Unmarshal(res.Body(), &respValue)
	if err != nil {
		return nil, err
	}
	// process result
	bz, _ := json.Marshal(respValue)
	if err != nil {
		return nil, err
	}

	result := []string{fmt.Sprintf("url: %s", link)}
	result = append(result, compareJSON(bz, res.Body())...)
	return result, nil
}

///////////////

type resultGetBlockTransactions struct {
	Ok     bool `json:"ok"`
	Result struct {
		Count int64 `json:"count"`
		Txs   []struct {
			Hash      string `json:"hash"`
			Timestamp string `json:"timestamp"`
			Status    string `json:"status"`
			Type      string `json:"type"`
			Fee       struct {
				Data struct {
					Gas_coin        string `json:"gas_coin"`
					Gas_used        string `json:"gas_used"`
					Gas_amount      string `json:"gas_amount"`
					Gas_used_number uint64 `json:"gas_used_number"`
				} `json:"data"`
			} `json:"fee"`
			Data struct {
				Coin               string `json:"coin"`
				Amount             string `json:"amount"`
				Issuer             string `json:"issuer"`
				Sender             string `json:"sender"`
				EvmDataTransaction struct {
					Coin      string `json:"coin"`
					Amount    string `json:"amount"`
					Sender    string `json:"sender"`
					Recipient string `json:"recipient"`
				} `json:"evmDataTransaction"`
			} `json:"data"`
			Nonce              uint64 `json:"nonce"`
			Code               uint64 `json:"code"`
			BlockId            uint64 `json:"blockId"`
			Message            string `json:"message"`
			From               uint64 `json:"from"`
			To                 uint64 `json:"to"`
			MultisendReceivers []struct {
				Address string `json:"address"`
				Amount  string `json:"amount"`
				Coin    string `json:"coin"`
			} `json:"multisendReceivers"`
			Sender struct {
				Address string `json:"address"`
			} `json:"sender"`
			Recipient struct {
				Address string `json:"address"`
			} `json:"recipient"`
		} `json:"txs"`
	} `json:"result"`
}

// /block/{height}/txs
// Get block's transactions
func (api *API) VerificationGetBlockTransactions(height uint64) ([]string, error) {

	var r = strings.NewReplacer(
		"{height}", fmt.Sprintf("%d", height),
	)
	var link = r.Replace("/block/{height}/txs")

	// request
	res, err := api.client.R().Get(link)
	if err != nil {
		return nil, err
	}
	if res.StatusCode() != 200 {
		return nil, fmt.Errorf("status: %d", res.StatusCode())
	}

	// json decode
	respValue := resultGetBlockTransactions{}
	err = json.Unmarshal(res.Body(), &respValue)
	if err != nil {
		return nil, err
	}
	// process result
	bz, _ := json.Marshal(respValue)
	if err != nil {
		return nil, err
	}

	result := []string{fmt.Sprintf("url: %s", link)}
	result = append(result, compareJSON(bz, res.Body())...)
	return result, nil
}

///////////////

type resultGetEvmContracts struct {
	Ok     bool `json:"ok"`
	Result struct {
		Count        uint64 `json:"count"`
		EvmContracts []struct {
			Address          string      `json:"address"`
			Status           string      `json:"status"`
			Abi              interface{} `json:"abi"`
			ByteCode         string      `json:"byteCode"`
			SourceCode       string      `json:"sourceCode"`
			SecurityAudit    string      `json:"securityAudit"`
			SwarmSource      string      `json:"swarmSource"`
			VerificationData struct {
				VerifiedAt           string `json:"verifiedAt"`
				MatchType            string `json:"matchType"`
				CompilerVersion      string `json:"compilerVersion"`
				EvmVersion           string `json:"evmVersion"`
				Optimization         bool   `json:"optimization"`
				OptimizeRuns         uint64 `json:"optimizeRuns"`
				ConstructorArguments string `json:"constructorArguments"`
				Metadata             struct {
					String string `json:"string"`
				} `json:"metadata"`
			} `json:"verificationData"`
			DeploymentEvmAccountAddress  string `json:"deploymentEvmAccountAddress"`
			DeploymentEvmBlockHeight     uint64 `json:"deploymentEvmBlockHeight"`
			DeploymentEvmTransactionHash string `json:"deploymentEvmTransactionHash"`
			DeploymentEvmReceiptId       uint64 `json:"deploymentEvmReceiptId"`
			EvmAccountAddress            string `json:"evmAccountAddress"`
			CreatedAt                    string `json:"createdAt"`
		} `json:"evmContracts"`
	} `json:"result"`
}

// /evm-contracts
// Get evm contracts
func (api *API) VerificationGetEvmContracts(opt *OptionalParams) ([]string, error) {

	var link = "/evm-contracts"
	if opt != nil {
		link += opt.String()
	}

	// request
	res, err := api.client.R().Get(link)
	if err != nil {
		return nil, err
	}
	if res.StatusCode() != 200 {
		return nil, fmt.Errorf("status: %d", res.StatusCode())
	}

	// json decode
	respValue := resultGetEvmContracts{}
	err = json.Unmarshal(res.Body(), &respValue)
	if err != nil {
		return nil, err
	}
	// process result
	bz, _ := json.Marshal(respValue)
	if err != nil {
		return nil, err
	}

	result := []string{fmt.Sprintf("url: %s", link)}
	result = append(result, compareJSON(bz, res.Body())...)
	return result, nil
}

///////////////

type resultGetEvmTransactions struct {
	Ok     bool `json:"ok"`
	Result struct {
		Count           uint64 `json:"count"`
		EvmTransactions []struct {
			Hash                 string      `json:"hash"`
			V                    string      `json:"v"`
			R                    string      `json:"r"`
			S                    string      `json:"s"`
			Gas                  uint64      `json:"gas"`
			Type                 string      `json:"type"`
			Input                string      `json:"input"`
			Nonce                uint64      `json:"nonce"`
			Value                string      `json:"value"`
			ChainId              uint64      `json:"chainId"`
			GasPrice             string      `json:"gasPrice"`
			AccessList           interface{} `json:"accessList"`
			MaxFeePerGas         uint64      `json:"maxFeePerGas"`
			MaxPriorityFeePerGas uint64      `json:"maxPriorityFeePerGas"`
			ExtraData            interface{} `json:"extraData"`
			From                 string      `json:"from"`
			To                   string      `json:"to"`
			EvmBlockHeight       uint64      `json:"evmBlockHeight"`
			CreatedAt            string      `json:"createdAt"`
		} `json:"evmTransactions"`
	} `json:"result"`
}

// /evm-transactions
// Get evm transactions
func (api *API) VerificationGetEvmTransactions(opt *OptionalParams) ([]string, error) {

	var link = "/evm-transactions"
	if opt != nil {
		link += opt.String()
	}

	// request
	res, err := api.client.R().Get(link)
	if err != nil {
		return nil, err
	}
	if res.StatusCode() != 200 {
		return nil, fmt.Errorf("status: %d", res.StatusCode())
	}

	// json decode
	respValue := resultGetEvmTransactions{}
	err = json.Unmarshal(res.Body(), &respValue)
	if err != nil {
		return nil, err
	}
	// process result
	bz, _ := json.Marshal(respValue)
	if err != nil {
		return nil, err
	}

	result := []string{fmt.Sprintf("url: %s", link)}
	result = append(result, compareJSON(bz, res.Body())...)
	return result, nil
}

///////////////

type resultGetEvmAccounts struct {
	Ok     bool `json:"ok"`
	Result struct {
		Count       uint64 `json:"count"`
		EvmAccounts []struct {
			Address                    string `json:"address"`
			CosmosAccountAddress       string `json:"cosmosAccountAddress"`
			CreationEvmBlockHeight     uint64 `json:"creationEvmBlockHeight"`
			CreationEvmTransactionHash string `json:"creationEvmTransactionHash"`
			CreatedAt                  string `json:"createdAt"`
		} `json:"evmAccounts"`
	} `json:"result"`
}

// /evm-accounts
// Get evm accounts
func (api *API) VerificationGetEvmAccounts(opt *OptionalParams) ([]string, error) {

	var link = "/evm-accounts"
	if opt != nil {
		link += opt.String()
	}

	// request
	res, err := api.client.R().Get(link)
	if err != nil {
		return nil, err
	}
	if res.StatusCode() != 200 {
		return nil, fmt.Errorf("status: %d", res.StatusCode())
	}

	// json decode
	respValue := resultGetEvmAccounts{}
	err = json.Unmarshal(res.Body(), &respValue)
	if err != nil {
		return nil, err
	}
	// process result
	bz, _ := json.Marshal(respValue)
	if err != nil {
		return nil, err
	}

	result := []string{fmt.Sprintf("url: %s", link)}
	result = append(result, compareJSON(bz, res.Body())...)
	return result, nil
}

///////////////

type resultGetEvmContract struct {
	Ok     bool `json:"ok"`
	Result struct {
		Address          string      `json:"address"`
		Status           string      `json:"status"`
		Abi              interface{} `json:"abi"`
		ByteCode         string      `json:"byteCode"`
		SourceCode       string      `json:"sourceCode"`
		SecurityAudit    string      `json:"securityAudit"`
		SwarmSource      string      `json:"swarmSource"`
		VerificationData struct {
			VerifiedAt           string `json:"verifiedAt"`
			MatchType            string `json:"matchType"`
			CompilerVersion      string `json:"compilerVersion"`
			EvmVersion           string `json:"evmVersion"`
			Optimization         bool   `json:"optimization"`
			OptimizeRuns         uint64 `json:"optimizeRuns"`
			ConstructorArguments string `json:"constructorArguments"`
			Metadata             struct {
				String string `json:"string"`
			} `json:"metadata"`
		} `json:"verificationData"`
		DeploymentEvmAccountAddress  string `json:"deploymentEvmAccountAddress"`
		DeploymentEvmBlockHeight     uint64 `json:"deploymentEvmBlockHeight"`
		DeploymentEvmTransactionHash string `json:"deploymentEvmTransactionHash"`
		DeploymentEvmReceiptId       uint64 `json:"deploymentEvmReceiptId"`
		EvmAccountAddress            string `json:"evmAccountAddress"`
		CreatedAt                    string `json:"createdAt"`
	} `json:"result"`
}

// /evm-contracts/{address}
// Get evm contract by address
func (api *API) VerificationGetEvmContract(address string) ([]string, error) {

	var r = strings.NewReplacer(
		"{address}", fmt.Sprintf("%s", address),
	)
	var link = r.Replace("/evm-contracts/{address}")

	// request
	res, err := api.client.R().Get(link)
	if err != nil {
		return nil, err
	}
	if res.StatusCode() != 200 {
		return nil, fmt.Errorf("status: %d", res.StatusCode())
	}

	// json decode
	respValue := resultGetEvmContract{}
	err = json.Unmarshal(res.Body(), &respValue)
	if err != nil {
		return nil, err
	}
	// process result
	bz, _ := json.Marshal(respValue)
	if err != nil {
		return nil, err
	}

	result := []string{fmt.Sprintf("url: %s", link)}
	result = append(result, compareJSON(bz, res.Body())...)
	return result, nil
}

///////////////

type resultGetEvmTransaction struct {
	Ok     bool `json:"ok"`
	Result struct {
		Hash                 string      `json:"hash"`
		V                    string      `json:"v"`
		R                    string      `json:"r"`
		S                    string      `json:"s"`
		Gas                  uint64      `json:"gas"`
		Type                 string      `json:"type"`
		Input                string      `json:"input"`
		Nonce                uint64      `json:"nonce"`
		Value                string      `json:"value"`
		ChainId              uint64      `json:"chainId"`
		GasPrice             string      `json:"gasPrice"`
		AccessList           interface{} `json:"accessList"`
		MaxFeePerGas         uint64      `json:"maxFeePerGas"`
		MaxPriorityFeePerGas uint64      `json:"maxPriorityFeePerGas"`
		ExtraData            interface{} `json:"extraData"`
		From                 string      `json:"from"`
		To                   string      `json:"to"`
		EvmBlockHeight       uint64      `json:"evmBlockHeight"`
		CreatedAt            string      `json:"createdAt"`
	} `json:"result"`
}

// /evm-transactions/{hash}
// Get evm transaction by hash
func (api *API) VerificationGetEvmTransaction(hash string) ([]string, error) {

	var r = strings.NewReplacer(
		"{hash}", fmt.Sprintf("%s", hash),
	)
	var link = r.Replace("/evm-transactions/{hash}")

	// request
	res, err := api.client.R().Get(link)
	if err != nil {
		return nil, err
	}
	if res.StatusCode() != 200 {
		return nil, fmt.Errorf("status: %d", res.StatusCode())
	}

	// json decode
	respValue := resultGetEvmTransaction{}
	err = json.Unmarshal(res.Body(), &respValue)
	if err != nil {
		return nil, err
	}
	// process result
	bz, _ := json.Marshal(respValue)
	if err != nil {
		return nil, err
	}

	result := []string{fmt.Sprintf("url: %s", link)}
	result = append(result, compareJSON(bz, res.Body())...)
	return result, nil
}

///////////////

type resultGetEvmAccount struct {
	Ok     bool `json:"ok"`
	Result struct {
		Address                    string `json:"address"`
		CosmosAccountAddress       string `json:"cosmosAccountAddress"`
		CreationEvmBlockHeight     uint64 `json:"creationEvmBlockHeight"`
		CreationEvmTransactionHash string `json:"creationEvmTransactionHash"`
		CreatedAt                  string `json:"createdAt"`
	} `json:"result"`
}

// /evm-accounts/{address}
// Get evm account by address
func (api *API) VerificationGetEvmAccount(address string) ([]string, error) {

	var r = strings.NewReplacer(
		"{address}", fmt.Sprintf("%s", address),
	)
	var link = r.Replace("/evm-accounts/{address}")

	// request
	res, err := api.client.R().Get(link)
	if err != nil {
		return nil, err
	}
	if res.StatusCode() != 200 {
		return nil, fmt.Errorf("status: %d", res.StatusCode())
	}

	// json decode
	respValue := resultGetEvmAccount{}
	err = json.Unmarshal(res.Body(), &respValue)
	if err != nil {
		return nil, err
	}
	// process result
	bz, _ := json.Marshal(respValue)
	if err != nil {
		return nil, err
	}

	result := []string{fmt.Sprintf("url: %s", link)}
	result = append(result, compareJSON(bz, res.Body())...)
	return result, nil
}

///////////////

type resultGetEvmContractTransactions struct {
	Ok     bool `json:"ok"`
	Result struct {
		Count                   uint64 `json:"count"`
		EvmContractTransactions []struct {
			Hash                 string      `json:"hash"`
			V                    string      `json:"v"`
			R                    string      `json:"r"`
			S                    string      `json:"s"`
			Gas                  uint64      `json:"gas"`
			Type                 string      `json:"type"`
			Input                string      `json:"input"`
			Nonce                uint64      `json:"nonce"`
			Value                string      `json:"value"`
			ChainId              uint64      `json:"chainId"`
			GasPrice             string      `json:"gasPrice"`
			AccessList           interface{} `json:"accessList"`
			MaxFeePerGas         uint64      `json:"maxFeePerGas"`
			MaxPriorityFeePerGas uint64      `json:"maxPriorityFeePerGas"`
			ExtraData            interface{} `json:"extraData"`
			From                 string      `json:"from"`
			To                   string      `json:"to"`
			EvmBlockHeight       uint64      `json:"evmBlockHeight"`
			CreatedAt            string      `json:"createdAt"`
		} `json:"evmContractTransactions"`
	} `json:"result"`
}

// /evm-contracts/{address}/transactions
// Get evm contract transactions
func (api *API) VerificationGetEvmContractTransactions(address string, opt *OptionalParams) ([]string, error) {

	var r = strings.NewReplacer(
		"{address}", fmt.Sprintf("%s", address),
	)
	var link = r.Replace("/evm-contracts/{address}/transactions")
	if opt != nil {
		link += opt.String()
	}

	// request
	res, err := api.client.R().Get(link)
	if err != nil {
		return nil, err
	}
	if res.StatusCode() != 200 {
		return nil, fmt.Errorf("status: %d", res.StatusCode())
	}

	// json decode
	respValue := resultGetEvmContractTransactions{}
	err = json.Unmarshal(res.Body(), &respValue)
	if err != nil {
		return nil, err
	}
	// process result
	bz, _ := json.Marshal(respValue)
	if err != nil {
		return nil, err
	}

	result := []string{fmt.Sprintf("url: %s", link)}
	result = append(result, compareJSON(bz, res.Body())...)
	return result, nil
}

///////////////

type resultGetEvmContractEvents struct {
	Ok     bool `json:"ok"`
	Result struct {
		Count             uint64 `json:"count"`
		EvmContractEvents []struct {
			Id                 uint64      `json:"id"`
			Root               string      `json:"root"`
			Type               uint64      `json:"type"`
			Status             bool        `json:"status"`
			GasUsed            uint64      `json:"gasUsed"`
			LogsBloom          string      `json:"logsBloom"`
			TransactionIndex   uint64      `json:"transactionIndex"`
			CumulativeGasUsed  uint64      `json:"cumulativeGasUsed"`
			ExtraData          interface{} `json:"extraData"`
			EvmBlockHeight     uint64      `json:"evmBlockHeight"`
			EvmTransactionHash string      `json:"evmTransactionHash"`
			ContractAddress    string      `json:"contractAddress"`
			CreatedAt          string      `json:"createdAt"`
			EvmReceiptLogs     []struct {
				Id                 uint64      `json:"id"`
				Data               string      `json:"data"`
				Address            string      `json:"address"`
				Removed            bool        `json:"removed"`
				LogIndex           uint64      `json:"logIndex"`
				ExtraData          interface{} `json:"extraData"`
				EvmBlockHeight     uint64      `json:"evmBlockHeight"`
				EvmTransactionHash string      `json:"evmTransactionHash"`
				EvmReceiptId       uint64      `json:"evmReceiptId"`
				Topics             []string    `json:"topics"`
				CreatedAt          string      `json:"createdAt"`
			} `json:"evmReceiptLogs"`
			EvmTransaction struct {
				Hash                 string      `json:"hash"`
				V                    string      `json:"v"`
				R                    string      `json:"r"`
				S                    string      `json:"s"`
				Gas                  uint64      `json:"gas"`
				Type                 string      `json:"type"`
				Input                string      `json:"input"`
				Nonce                uint64      `json:"nonce"`
				Value                string      `json:"value"`
				ChainId              uint64      `json:"chainId"`
				GasPrice             string      `json:"gasPrice"`
				AccessList           interface{} `json:"accessList"`
				MaxFeePerGas         uint64      `json:"maxFeePerGas"`
				MaxPriorityFeePerGas uint64      `json:"maxPriorityFeePerGas"`
				ExtraData            interface{} `json:"extraData"`
				From                 string      `json:"from"`
				To                   string      `json:"to"`
				EvmBlockHeight       uint64      `json:"evmBlockHeight"`
				CreatedAt            string      `json:"createdAt"`
			} `json:"evmTransaction"`
		} `json:"evmContractEvents"`
	} `json:"result"`
}

// /evm-contracts/{address}/events
// Get evm contract events
func (api *API) VerificationGetEvmContractEvents(address string, opt *OptionalParams) ([]string, error) {

	var r = strings.NewReplacer(
		"{address}", fmt.Sprintf("%s", address),
	)
	var link = r.Replace("/evm-contracts/{address}/events")
	if opt != nil {
		link += opt.String()
	}

	// request
	res, err := api.client.R().Get(link)
	if err != nil {
		return nil, err
	}
	if res.StatusCode() != 200 {
		return nil, fmt.Errorf("status: %d", res.StatusCode())
	}

	// json decode
	respValue := resultGetEvmContractEvents{}
	err = json.Unmarshal(res.Body(), &respValue)
	if err != nil {
		return nil, err
	}
	// process result
	bz, _ := json.Marshal(respValue)
	if err != nil {
		return nil, err
	}

	result := []string{fmt.Sprintf("url: %s", link)}
	result = append(result, compareJSON(bz, res.Body())...)
	return result, nil
}

///////////////

type resultGetEvmAccountBalances struct {
	Ok     bool `json:"ok"`
	Result struct {
		Count                  uint64 `json:"count"`
		EvmTokenAccountBalance []struct {
			Address                      string `json:"address"`
			CosmosAccountAddress         string `json:"cosmosAccountAddress"`
			CreationEvmBlockHeight       uint64 `json:"creationEvmBlockHeight"`
			CreationEvmTransactionHash   string `json:"creationEvmTransactionHash"`
			EvmAccountERC20TokenBalances []struct {
				EvmTokenAddress   string `json:"evmTokenAddress"`
				EvmAccountAddress string `json:"evmAccountAddress"`
				Amount            string `json:"amount"`
				EvmToken          struct {
					Decimals           string `json:"decimals"`
					Address            string `json:"address"`
					Title              string `json:"title"`
					Symbol             string `json:"symbol"`
					EvmContractAddress string `json:"evmContractAddress"`
					EvmTokenTypeName   string `json:"evmTokenTypeName"`
					TotalSupply        string `json:"totalSupply"`
					EvmContract        struct {
						Address                      string `json:"address"`
						Status                       string `json:"status"`
						DeploymentEvmAccountAddress  string `json:"deploymentEvmAccountAddress"`
						DeploymentEvmBlockHeight     uint64 `json:"deploymentEvmBlockHeight"`
						DeploymentEvmTransactionHash string `json:"deploymentEvmTransactionHash"`
						DeploymentEvmReceiptId       uint64 `json:"deploymentEvmReceiptId"`
						EvmAccountAddress            string `json:"evmAccountAddress"`
					} `json:"evmContract"`
				} `json:"evmToken"`
			} `json:"evmAccountERC20TokenBalances"`
			EvmAccountERC721TokenBalance []struct {
				EvmTokenAddress   string `json:"evmTokenAddress"`
				EvmAccountAddress string `json:"evmAccountAddress"`
				Amount            string `json:"amount"`
				EvmToken          struct {
					Decimals           string `json:"decimals"`
					Address            string `json:"address"`
					Title              string `json:"title"`
					Symbol             string `json:"symbol"`
					EvmContractAddress string `json:"evmContractAddress"`
					EvmTokenTypeName   string `json:"evmTokenTypeName"`
					TotalSupply        string `json:"totalSupply"`
					EvmContract        struct {
						Address                      string `json:"address"`
						Status                       string `json:"status"`
						DeploymentEvmAccountAddress  string `json:"deploymentEvmAccountAddress"`
						DeploymentEvmBlockHeight     uint64 `json:"deploymentEvmBlockHeight"`
						DeploymentEvmTransactionHash string `json:"deploymentEvmTransactionHash"`
						DeploymentEvmReceiptId       uint64 `json:"deploymentEvmReceiptId"`
						EvmAccountAddress            string `json:"evmAccountAddress"`
					} `json:"evmContract"`
				} `json:"evmToken"`
			} `json:"evmAccountERC721TokenBalance"`
			EvmAccountERC1155TokenBalance []struct {
				EvmTokenAddress   string `json:"evmTokenAddress"`
				EvmAccountAddress string `json:"evmAccountAddress"`
				Amount            string `json:"amount"`
				EvmToken          struct {
					Decimals           string `json:"decimals"`
					Address            string `json:"address"`
					Title              string `json:"title"`
					Symbol             string `json:"symbol"`
					EvmContractAddress string `json:"evmContractAddress"`
					EvmTokenTypeName   string `json:"evmTokenTypeName"`
					TotalSupply        string `json:"totalSupply"`
					EvmContract        struct {
						Address                      string `json:"address"`
						Status                       string `json:"status"`
						DeploymentEvmAccountAddress  string `json:"deploymentEvmAccountAddress"`
						DeploymentEvmBlockHeight     uint64 `json:"deploymentEvmBlockHeight"`
						DeploymentEvmTransactionHash string `json:"deploymentEvmTransactionHash"`
						DeploymentEvmReceiptId       uint64 `json:"deploymentEvmReceiptId"`
						EvmAccountAddress            string `json:"evmAccountAddress"`
					} `json:"evmContract"`
				} `json:"evmToken"`
			} `json:"evmAccountERC1155TokenBalance"`
		} `json:"evmTokenAccountBalance"`
	} `json:"result"`
}

// /evm-accounts/{address}/balances
// Get evm contract events
func (api *API) VerificationGetEvmAccountBalances(address string, opt *OptionalParams) ([]string, error) {

	var r = strings.NewReplacer(
		"{address}", fmt.Sprintf("%s", address),
	)
	var link = r.Replace("/evm-accounts/{address}/balances")
	if opt != nil {
		link += opt.String()
	}

	// request
	res, err := api.client.R().Get(link)
	if err != nil {
		return nil, err
	}
	if res.StatusCode() != 200 {
		return nil, fmt.Errorf("status: %d", res.StatusCode())
	}

	// json decode
	respValue := resultGetEvmAccountBalances{}
	err = json.Unmarshal(res.Body(), &respValue)
	if err != nil {
		return nil, err
	}
	// process result
	bz, _ := json.Marshal(respValue)
	if err != nil {
		return nil, err
	}

	result := []string{fmt.Sprintf("url: %s", link)}
	result = append(result, compareJSON(bz, res.Body())...)
	return result, nil
}

///////////////

type resultGetValidatorsByKind struct {
	Ok     bool `json:"ok"`
	Result struct {
		Count      int64 `json:"count"`
		Online     int64 `json:"online"`
		Validators []struct {
			Address          string `json:"address"`
			ConsensusAddress string `json:"consensusAddress"`
			RewardAddress    string `json:"rewardAddress"`
			Moniker          string `json:"moniker"`
			Website          string `json:"website"`
			Details          string `json:"details"`
			Identity         string `json:"identity"`
			Security_contact string `json:"security_contact"`
			BlockId          uint64 `json:"blockId"`
			SkippedBlocks    uint64 `json:"skippedBlocks"`
			Delegators       uint64 `json:"delegators"`
			Fee              string `json:"fee"`
			Slots            uint64 `json:"slots"`
			Mins             string `json:"mins"`
			Stake            string `json:"stake"`
			Power            string `json:"power"`
			Rating           string `json:"rating"`
			Status           string `json:"status"`
			Kind             string `json:"kind"`
		} `json:"validators"`
		FreeSlots int64 `json:"freeSlots"`
	} `json:"result"`
}

// /validators/{kind}
// Default route
func (api *API) VerificationGetValidatorsByKind(kind string) ([]string, error) {

	var r = strings.NewReplacer(
		"{kind}", fmt.Sprintf("%s", kind),
	)
	var link = r.Replace("/validators/{kind}")

	// request
	res, err := api.client.R().Get(link)
	if err != nil {
		return nil, err
	}
	if res.StatusCode() != 200 {
		return nil, fmt.Errorf("status: %d", res.StatusCode())
	}

	// json decode
	respValue := resultGetValidatorsByKind{}
	err = json.Unmarshal(res.Body(), &respValue)
	if err != nil {
		return nil, err
	}
	// process result
	bz, _ := json.Marshal(respValue)
	if err != nil {
		return nil, err
	}

	result := []string{fmt.Sprintf("url: %s", link)}
	result = append(result, compareJSON(bz, res.Body())...)
	return result, nil
}

///////////////

type resultGetValidator struct {
	Ok     bool `json:"ok"`
	Result struct {
		Address          string `json:"address"`
		ConsensusAddress string `json:"consensusAddress"`
		RewardAddress    string `json:"rewardAddress"`
		Moniker          string `json:"moniker"`
		Website          string `json:"website"`
		Details          string `json:"details"`
		Identity         string `json:"identity"`
		Security_contact string `json:"security_contact"`
		BlockId          uint64 `json:"blockId"`
		SkippedBlocks    uint64 `json:"skippedBlocks"`
		Delegators       uint64 `json:"delegators"`
		Fee              string `json:"fee"`
		Slots            uint64 `json:"slots"`
		Mins             string `json:"mins"`
		Stake            string `json:"stake"`
		Power            string `json:"power"`
		Rating           string `json:"rating"`
		Status           string `json:"status"`
		Kind             string `json:"kind"`
	} `json:"result"`
}

// /validator/{address}
// Get validator by address (public key)
func (api *API) VerificationGetValidator(address string) ([]string, error) {

	var r = strings.NewReplacer(
		"{address}", fmt.Sprintf("%s", address),
	)
	var link = r.Replace("/validator/{address}")

	// request
	res, err := api.client.R().Get(link)
	if err != nil {
		return nil, err
	}
	if res.StatusCode() != 200 {
		return nil, fmt.Errorf("status: %d", res.StatusCode())
	}

	// json decode
	respValue := resultGetValidator{}
	err = json.Unmarshal(res.Body(), &respValue)
	if err != nil {
		return nil, err
	}
	// process result
	bz, _ := json.Marshal(respValue)
	if err != nil {
		return nil, err
	}

	result := []string{fmt.Sprintf("url: %s", link)}
	result = append(result, compareJSON(bz, res.Body())...)
	return result, nil
}

///////////////

type resultGetValidatorStakes struct {
	Ok     bool `json:"ok"`
	Result struct {
		Count  int64 `json:"count"`
		Stakes []struct {
			Amount           string `json:"amount"`
			CoinSymbol       string `json:"coinSymbol"`
			BaseAmount       string `json:"baseAmount"`
			UnbondAmount     string `json:"unbondAmount"`
			UnbondBaseAmount string `json:"unbondBaseAmount"`
			AddressId        string `json:"addressId"`
			ValidatorId      string `json:"validatorId"`
			CreatedAt        string `json:"createdAt"`
			UpdatedAt        string `json:"updatedAt"`
			Coin             struct {
				Avatar string `json:"avatar"`
			} `json:"coin"`
		} `json:"stakes"`
	} `json:"result"`
}

// /validator/{address}/stakes
// Get validator's stake
func (api *API) VerificationGetValidatorStakes(address string, opt *OptionalParams) ([]string, error) {

	var r = strings.NewReplacer(
		"{address}", fmt.Sprintf("%s", address),
	)
	var link = r.Replace("/validator/{address}/stakes")
	if opt != nil {
		link += opt.String()
	}

	// request
	res, err := api.client.R().Get(link)
	if err != nil {
		return nil, err
	}
	if res.StatusCode() != 200 {
		return nil, fmt.Errorf("status: %d", res.StatusCode())
	}

	// json decode
	respValue := resultGetValidatorStakes{}
	err = json.Unmarshal(res.Body(), &respValue)
	if err != nil {
		return nil, err
	}
	// process result
	bz, _ := json.Marshal(respValue)
	if err != nil {
		return nil, err
	}

	result := []string{fmt.Sprintf("url: %s", link)}
	result = append(result, compareJSON(bz, res.Body())...)
	return result, nil
}

///////////////

type resultGetValidatorStakesNFT struct {
	Ok     bool `json:"ok"`
	Result struct {
		Count  int64 `json:"count"`
		Stakes []struct {
			BaseQuantity string `json:"baseQuantity"`
			AddressId    string `json:"addressId"`
			Count        uint64 `json:"count"`
			Nft          struct {
				NftCollection string `json:"nftCollection"`
				NftId         string `json:"nftId"`
				TokenUri      string `json:"tokenUri"`
			} `json:"nft"`
			Cover string `json:"cover"`
		} `json:"stakes"`
	} `json:"result"`
}

// /validator/{address}/stakes/nfts
// Get validator's NFTs stake
func (api *API) VerificationGetValidatorStakesNFT(address string) ([]string, error) {

	var r = strings.NewReplacer(
		"{address}", fmt.Sprintf("%s", address),
	)
	var link = r.Replace("/validator/{address}/stakes/nfts")

	// request
	res, err := api.client.R().Get(link)
	if err != nil {
		return nil, err
	}
	if res.StatusCode() != 200 {
		return nil, fmt.Errorf("status: %d", res.StatusCode())
	}

	// json decode
	respValue := resultGetValidatorStakesNFT{}
	err = json.Unmarshal(res.Body(), &respValue)
	if err != nil {
		return nil, err
	}
	// process result
	bz, _ := json.Marshal(respValue)
	if err != nil {
		return nil, err
	}

	result := []string{fmt.Sprintf("url: %s", link)}
	result = append(result, compareJSON(bz, res.Body())...)
	return result, nil
}
