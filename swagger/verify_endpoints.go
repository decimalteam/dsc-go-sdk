package swagger

// This file is autogenerated. DO NOT EDIT

import (
	"encoding/json"
	"fmt"
	"strings"
)

///////////////

type resultGetAddress struct {
	Ok     bool `json:"ok"`
	Result struct {
		CreatedAt string `json:"createdAt"`
		UpdatedAt string `json:"updatedAt"`
		Address   string `json:"address"`
		Type      string `json:"type"`
		Balance   struct {
			Del string `json:"del"`
		} `json:"balance"`
		BalanceNft []struct {
			NftId      string `json:"nftId"`
			Amount     string `json:"amount"`
			Collection string `json:"collection"`
		} `json:"balanceNft"`
		Nonce         uint64 `json:"nonce"`
		Txes          uint64 `json:"txes"`
		UnbondBalance struct {
			Del string `json:"del"`
		} `json:"unbondBalance"`
		StakeBalance struct {
			Del string `json:"del"`
		} `json:"stakeBalance"`
	} `json:"result"`
}

// /address/{id}
// Get address by id
func (api *API) VerificationGetAddress(id string) ([]string, error) {

	var r = strings.NewReplacer(
		"{id}", fmt.Sprintf("%s", id),
	)
	var link = r.Replace("/address/{id}")

	// request
	res, err := api.client.R().Get(link)
	if err != nil {
		return nil, err
	}
	if res.StatusCode() != 200 {
		return nil, fmt.Errorf("status: %d", res.StatusCode())
	}

	// json decode
	respValue := resultGetAddress{}
	err = json.Unmarshal(res.Body(), &respValue)
	if err != nil {
		return nil, err
	}
	// process result
	bz, _ := json.Marshal(respValue)
	if err != nil {
		return nil, err
	}

	result := []string{fmt.Sprintf("url: %s", link)}
	result = append(result, compareJSON(bz, res.Body())...)
	return result, nil
}

///////////////

type resultGetAddressTxs struct {
	Ok     bool `json:"ok"`
	Result struct {
		Count int64 `json:"count"`
		Txs   []struct {
			CreatedAt string `json:"createdAt"`
			UpdatedAt string `json:"updatedAt"`
			Hash      string `json:"hash"`
			Timestamp string `json:"timestamp"`
			Status    uint64 `json:"status"`
			Type      string `json:"type"`
			Fee       struct {
				Coin   string `json:"coin"`
				Amount string `json:"amount"`
			} `json:"fee"`
			Data    interface{} `json:"data"`
			Nonce   int64       `json:"nonce"`
			BlockId int64       `json:"blockId"`
			Message string      `json:"message"`
			From    string      `json:"from"`
			To      string      `json:"to"`
		} `json:"txs"`
	} `json:"result"`
}

// /address/{id}/txs
// Get address's transactions
func (api *API) VerificationGetAddressTxs(id string, opt *OptionalParams) ([]string, error) {

	var r = strings.NewReplacer(
		"{id}", fmt.Sprintf("%s", id),
	)
	var link = r.Replace("/address/{id}/txs")
	if opt != nil {
		link += opt.String()
	}

	// request
	res, err := api.client.R().Get(link)
	if err != nil {
		return nil, err
	}
	if res.StatusCode() != 200 {
		return nil, fmt.Errorf("status: %d", res.StatusCode())
	}

	// json decode
	respValue := resultGetAddressTxs{}
	err = json.Unmarshal(res.Body(), &respValue)
	if err != nil {
		return nil, err
	}
	// process result
	bz, _ := json.Marshal(respValue)
	if err != nil {
		return nil, err
	}

	result := []string{fmt.Sprintf("url: %s", link)}
	result = append(result, compareJSON(bz, res.Body())...)
	return result, nil
}

///////////////

type resultGetAddressStakes struct {
	Ok     bool `json:"ok"`
	Result struct {
		Count  int64 `json:"count"`
		Stakes []struct {
			CreatedAt   string `json:"createdAt"`
			UpdatedAt   string `json:"updatedAt"`
			CoinSymbol  string `json:"coinSymbol"`
			Amount      string `json:"amount"`
			AddressId   string `json:"addressId"`
			ValidatorId string `json:"validatorId"`
		} `json:"stakes"`
	} `json:"result"`
}

// /address/{address}/stakes
// Get address's stakes
func (api *API) VerificationGetAddressStakes(address string, opt *OptionalParams) ([]string, error) {

	var r = strings.NewReplacer(
		"{address}", fmt.Sprintf("%s", address),
	)
	var link = r.Replace("/address/{address}/stakes")
	if opt != nil {
		link += opt.String()
	}

	// request
	res, err := api.client.R().Get(link)
	if err != nil {
		return nil, err
	}
	if res.StatusCode() != 200 {
		return nil, fmt.Errorf("status: %d", res.StatusCode())
	}

	// json decode
	respValue := resultGetAddressStakes{}
	err = json.Unmarshal(res.Body(), &respValue)
	if err != nil {
		return nil, err
	}
	// process result
	bz, _ := json.Marshal(respValue)
	if err != nil {
		return nil, err
	}

	result := []string{fmt.Sprintf("url: %s", link)}
	result = append(result, compareJSON(bz, res.Body())...)
	return result, nil
}

///////////////

type resultGetAddressRewards struct {
	Ok     bool `json:"ok"`
	Result struct {
		Count   int64 `json:"count"`
		Rewards []struct {
			CreatedAt   string `json:"createdAt"`
			UpdatedAt   string `json:"updatedAt"`
			CoinSymbol  string `json:"coinSymbol"`
			Amount      string `json:"amount"`
			AddressId   string `json:"addressId"`
			ValidatorId string `json:"validatorId"`
		} `json:"rewards"`
	} `json:"result"`
}

// /address/{address}/rewards
// Get address's rewards
func (api *API) VerificationGetAddressRewards(address string, opt *OptionalParams) ([]string, error) {

	var r = strings.NewReplacer(
		"{address}", fmt.Sprintf("%s", address),
	)
	var link = r.Replace("/address/{address}/rewards")
	if opt != nil {
		link += opt.String()
	}

	// request
	res, err := api.client.R().Get(link)
	if err != nil {
		return nil, err
	}
	if res.StatusCode() != 200 {
		return nil, fmt.Errorf("status: %d", res.StatusCode())
	}

	// json decode
	respValue := resultGetAddressRewards{}
	err = json.Unmarshal(res.Body(), &respValue)
	if err != nil {
		return nil, err
	}
	// process result
	bz, _ := json.Marshal(respValue)
	if err != nil {
		return nil, err
	}

	result := []string{fmt.Sprintf("url: %s", link)}
	result = append(result, compareJSON(bz, res.Body())...)
	return result, nil
}

///////////////

type resultGetAllNFT struct {
	Ok     bool `json:"ok"`
	Result struct {
		Count int64 `json:"count"`
		Nfts  []struct {
			NftCollection string `json:"nftCollection"`
			NftId         string `json:"nftId"`
			Quantity      string `json:"quantity"`
			Reserve       string `json:"reserve"`
			Sender        string `json:"sender"`
			Recipient     string `json:"recipient"`
			TxHash        string `json:"txHash"`
		} `json:"nfts"`
	} `json:"result"`
}

// /nfts
// Get all nfts
func (api *API) VerificationGetAllNFT(opt *OptionalParams) ([]string, error) {

	var link = "/nfts"
	if opt != nil {
		link += opt.String()
	}

	// request
	res, err := api.client.R().Get(link)
	if err != nil {
		return nil, err
	}
	if res.StatusCode() != 200 {
		return nil, fmt.Errorf("status: %d", res.StatusCode())
	}

	// json decode
	respValue := resultGetAllNFT{}
	err = json.Unmarshal(res.Body(), &respValue)
	if err != nil {
		return nil, err
	}
	// process result
	bz, _ := json.Marshal(respValue)
	if err != nil {
		return nil, err
	}

	result := []string{fmt.Sprintf("url: %s", link)}
	result = append(result, compareJSON(bz, res.Body())...)
	return result, nil
}

///////////////

type resultGetNFTCollection struct {
	Ok     bool        `json:"ok"`
	Result interface{} `json:"result"`
}

// /nft/{collection}
// Get nft collection
func (api *API) VerificationGetNFTCollection(collection string) ([]string, error) {

	var r = strings.NewReplacer(
		"{collection}", fmt.Sprintf("%s", collection),
	)
	var link = r.Replace("/nft/{collection}")

	// request
	res, err := api.client.R().Get(link)
	if err != nil {
		return nil, err
	}
	if res.StatusCode() != 200 {
		return nil, fmt.Errorf("status: %d", res.StatusCode())
	}

	// json decode
	respValue := resultGetNFTCollection{}
	err = json.Unmarshal(res.Body(), &respValue)
	if err != nil {
		return nil, err
	}
	// process result
	bz, _ := json.Marshal(respValue)
	if err != nil {
		return nil, err
	}

	result := []string{fmt.Sprintf("url: %s", link)}
	result = append(result, compareJSON(bz, res.Body())...)
	return result, nil
}

///////////////

type resultGetNFTTransactions struct {
	Ok     bool `json:"ok"`
	Result struct {
		Count int64 `json:"count"`
		Txs   []struct {
			CreatedAt string `json:"createdAt"`
			UpdatedAt string `json:"updatedAt"`
			Hash      string `json:"hash"`
			Timestamp string `json:"timestamp"`
			Status    uint64 `json:"status"`
			Type      string `json:"type"`
			Fee       struct {
				Coin   string `json:"coin"`
				Amount string `json:"amount"`
			} `json:"fee"`
			Data    interface{} `json:"data"`
			Nonce   int64       `json:"nonce"`
			BlockId int64       `json:"blockId"`
			Message string      `json:"message"`
			From    string      `json:"from"`
			To      string      `json:"to"`
		} `json:"txs"`
	} `json:"result"`
}

// /nft/{collection}/{id}/txs
// Get nft's transactions
func (api *API) VerificationGetNFTTransactions(collection string, id string, opt *OptionalParams) ([]string, error) {

	var r = strings.NewReplacer(
		"{collection}", fmt.Sprintf("%s", collection),
		"{id}", fmt.Sprintf("%s", id),
	)
	var link = r.Replace("/nft/{collection}/{id}/txs")
	if opt != nil {
		link += opt.String()
	}

	// request
	res, err := api.client.R().Get(link)
	if err != nil {
		return nil, err
	}
	if res.StatusCode() != 200 {
		return nil, fmt.Errorf("status: %d", res.StatusCode())
	}

	// json decode
	respValue := resultGetNFTTransactions{}
	err = json.Unmarshal(res.Body(), &respValue)
	if err != nil {
		return nil, err
	}
	// process result
	bz, _ := json.Marshal(respValue)
	if err != nil {
		return nil, err
	}

	result := []string{fmt.Sprintf("url: %s", link)}
	result = append(result, compareJSON(bz, res.Body())...)
	return result, nil
}

///////////////

type resultGetTx struct {
	Ok     bool `json:"ok"`
	Result struct {
		CreatedAt string `json:"createdAt"`
		UpdatedAt string `json:"updatedAt"`
		Hash      string `json:"hash"`
		Timestamp string `json:"timestamp"`
		Status    uint64 `json:"status"`
		Type      string `json:"type"`
		Fee       struct {
			Coin   string `json:"coin"`
			Amount string `json:"amount"`
		} `json:"fee"`
		Data    interface{} `json:"data"`
		Nonce   int64       `json:"nonce"`
		BlockId int64       `json:"blockId"`
		Message string      `json:"message"`
		From    string      `json:"from"`
		To      string      `json:"to"`
	} `json:"result"`
}

// /tx/{hash}
// Get transaction by hash data
func (api *API) VerificationGetTxByHash(hash string) ([]string, error) {

	var r = strings.NewReplacer(
		"{hash}", fmt.Sprintf("%s", hash),
	)
	var link = r.Replace("/tx/{hash}")

	// request
	res, err := api.client.R().Get(link)
	if err != nil {
		return nil, err
	}
	if res.StatusCode() != 200 {
		return nil, fmt.Errorf("status: %d", res.StatusCode())
	}

	// json decode
	respValue := resultGetTx{}
	err = json.Unmarshal(res.Body(), &respValue)
	if err != nil {
		return nil, err
	}
	// process result
	bz, _ := json.Marshal(respValue)
	if err != nil {
		return nil, err
	}

	result := []string{fmt.Sprintf("url: %s", link)}
	result = append(result, compareJSON(bz, res.Body())...)
	return result, nil
}

///////////////

type resultGetTxs struct {
	Ok     bool `json:"ok"`
	Result struct {
		Count int64 `json:"count"`
		Txs   []struct {
			CreatedAt string `json:"createdAt"`
			UpdatedAt string `json:"updatedAt"`
			Hash      string `json:"hash"`
			Timestamp string `json:"timestamp"`
			Status    uint64 `json:"status"`
			Type      string `json:"type"`
			Fee       struct {
				Coin   string `json:"coin"`
				Amount string `json:"amount"`
			} `json:"fee"`
			Data    interface{} `json:"data"`
			Nonce   int64       `json:"nonce"`
			BlockId int64       `json:"blockId"`
			Message string      `json:"message"`
			From    string      `json:"from"`
			To      string      `json:"to"`
		} `json:"txs"`
	} `json:"result"`
}

// /txs
// Get all transactions
func (api *API) VerificationGetTxs(opt *OptionalParams) ([]string, error) {

	var link = "/txs"
	if opt != nil {
		link += opt.String()
	}

	// request
	res, err := api.client.R().Get(link)
	if err != nil {
		return nil, err
	}
	if res.StatusCode() != 200 {
		return nil, fmt.Errorf("status: %d", res.StatusCode())
	}

	// json decode
	respValue := resultGetTxs{}
	err = json.Unmarshal(res.Body(), &respValue)
	if err != nil {
		return nil, err
	}
	// process result
	bz, _ := json.Marshal(respValue)
	if err != nil {
		return nil, err
	}

	result := []string{fmt.Sprintf("url: %s", link)}
	result = append(result, compareJSON(bz, res.Body())...)
	return result, nil
}

///////////////

type resultGetCoins struct {
	Ok     bool `json:"ok"`
	Result struct {
		CountAllCoin int64  `json:"countAllCoin"`
		TotalReserve string `json:"totalReserve"`
		Coins        []struct {
			Symbol      string `json:"symbol"`
			Title       string `json:"title"`
			Volume      string `json:"volume"`
			Reserve     string `json:"reserve"`
			Crr         int64  `json:"crr"`
			LimitVolume string `json:"limitVolume"`
			Creator     string `json:"creator"`
			TxHash      string `json:"txHash"`
			BlockId     string `json:"blockId"`
			Price       string `json:"price"`
			Delegated   string `json:"delegated"`
			Avatar      string `json:"avatar"`
		} `json:"coins"`
	} `json:"result"`
}

// /coins
// Get all coins
func (api *API) VerificationGetCoins(opt *OptionalParams) ([]string, error) {

	var link = "/coins"
	if opt != nil {
		link += opt.String()
	}

	// request
	res, err := api.client.R().Get(link)
	if err != nil {
		return nil, err
	}
	if res.StatusCode() != 200 {
		return nil, fmt.Errorf("status: %d", res.StatusCode())
	}

	// json decode
	respValue := resultGetCoins{}
	err = json.Unmarshal(res.Body(), &respValue)
	if err != nil {
		return nil, err
	}
	// process result
	bz, _ := json.Marshal(respValue)
	if err != nil {
		return nil, err
	}

	result := []string{fmt.Sprintf("url: %s", link)}
	result = append(result, compareJSON(bz, res.Body())...)
	return result, nil
}

///////////////

type resultGetCoin struct {
	Ok     bool        `json:"ok"`
	Result interface{} `json:"result"`
}

// /coin/{coin}
// Get coin
func (api *API) VerificationGetCoin(coin string) ([]string, error) {

	var r = strings.NewReplacer(
		"{coin}", fmt.Sprintf("%s", coin),
	)
	var link = r.Replace("/coin/{coin}")

	// request
	res, err := api.client.R().Get(link)
	if err != nil {
		return nil, err
	}
	if res.StatusCode() != 200 {
		return nil, fmt.Errorf("status: %d", res.StatusCode())
	}

	// json decode
	respValue := resultGetCoin{}
	err = json.Unmarshal(res.Body(), &respValue)
	if err != nil {
		return nil, err
	}
	// process result
	bz, _ := json.Marshal(respValue)
	if err != nil {
		return nil, err
	}

	result := []string{fmt.Sprintf("url: %s", link)}
	result = append(result, compareJSON(bz, res.Body())...)
	return result, nil
}

///////////////

type resultGetBlocks struct {
	Ok     bool `json:"ok"`
	Result struct {
		Count  uint64 `json:"count"`
		Blocks []struct {
			CreatedAt       string `json:"createdAt"`
			UpdatedAt       string `json:"updatedAt"`
			Height          int64  `json:"height"`
			Date            string `json:"date"`
			Hash            string `json:"hash"`
			Size            int64  `json:"size"`
			Reward          int64  `json:"reward"`
			BlockTime       int64  `json:"blockTime"`
			TxsCount        int64  `json:"txsCount"`
			ValidatorsCount int64  `json:"validatorsCount"`
			ProposerId      string `json:"proposerId"`
		} `json:"blocks"`
	} `json:"result"`
}

// /blocks
// Get all blocks
func (api *API) VerificationGetBlocks(opt *OptionalParams) ([]string, error) {

	var link = "/blocks"
	if opt != nil {
		link += opt.String()
	}

	// request
	res, err := api.client.R().Get(link)
	if err != nil {
		return nil, err
	}
	if res.StatusCode() != 200 {
		return nil, fmt.Errorf("status: %d", res.StatusCode())
	}

	// json decode
	respValue := resultGetBlocks{}
	err = json.Unmarshal(res.Body(), &respValue)
	if err != nil {
		return nil, err
	}
	// process result
	bz, _ := json.Marshal(respValue)
	if err != nil {
		return nil, err
	}

	result := []string{fmt.Sprintf("url: %s", link)}
	result = append(result, compareJSON(bz, res.Body())...)
	return result, nil
}

///////////////

type resultGetBlock struct {
	Ok     bool `json:"ok"`
	Result struct {
		CreatedAt       string `json:"createdAt"`
		UpdatedAt       string `json:"updatedAt"`
		Height          int64  `json:"height"`
		Date            string `json:"date"`
		Hash            string `json:"hash"`
		Size            int64  `json:"size"`
		Reward          int64  `json:"reward"`
		BlockTime       int64  `json:"blockTime"`
		TxsCount        int64  `json:"txsCount"`
		ValidatorsCount int64  `json:"validatorsCount"`
		ProposerId      string `json:"proposerId"`
		EvmBlock        struct {
			CreatedAt         string      `json:"createdAt"`
			UpdatedAt         string      `json:"updatedAt"`
			Height            uint64      `json:"height"`
			Hash              string      `json:"hash"`
			Date              string      `json:"date"`
			Miner             string      `json:"miner"`
			BaseFeePerGas     uint64      `json:"baseFeePerGas"`
			GasUsed           uint64      `json:"gasUsed"`
			GasLimit          uint64      `json:"gasLimit"`
			Data              interface{} `json:"data"`
			TransactionsCount uint64      `json:"transactionsCount"`
			ReceiptsCount     uint64      `json:"receiptsCount"`
		} `json:"evmBlock"`
	} `json:"result"`
}

// /block/{height}
// Get block by id
func (api *API) VerificationGetBlockByHeight(height uint64) ([]string, error) {

	var r = strings.NewReplacer(
		"{height}", fmt.Sprintf("%d", height),
	)
	var link = r.Replace("/block/{height}")

	// request
	res, err := api.client.R().Get(link)
	if err != nil {
		return nil, err
	}
	if res.StatusCode() != 200 {
		return nil, fmt.Errorf("status: %d", res.StatusCode())
	}

	// json decode
	respValue := resultGetBlock{}
	err = json.Unmarshal(res.Body(), &respValue)
	if err != nil {
		return nil, err
	}
	// process result
	bz, _ := json.Marshal(respValue)
	if err != nil {
		return nil, err
	}

	result := []string{fmt.Sprintf("url: %s", link)}
	result = append(result, compareJSON(bz, res.Body())...)
	return result, nil
}

///////////////

type resultGetBlockTransactions struct {
	Ok     bool `json:"ok"`
	Result struct {
		Count int64 `json:"count"`
		Txs   []struct {
			CreatedAt string `json:"createdAt"`
			UpdatedAt string `json:"updatedAt"`
			Hash      string `json:"hash"`
			Timestamp string `json:"timestamp"`
			Status    uint64 `json:"status"`
			Type      string `json:"type"`
			Fee       struct {
				Coin   string `json:"coin"`
				Amount string `json:"amount"`
			} `json:"fee"`
			Data    interface{} `json:"data"`
			Nonce   int64       `json:"nonce"`
			BlockId int64       `json:"blockId"`
			Message string      `json:"message"`
			From    string      `json:"from"`
			To      string      `json:"to"`
		} `json:"txs"`
	} `json:"result"`
}

// /block/{height}/txs
// Get block's transactions
func (api *API) VerificationGetBlockTransactions(height uint64) ([]string, error) {

	var r = strings.NewReplacer(
		"{height}", fmt.Sprintf("%d", height),
	)
	var link = r.Replace("/block/{height}/txs")

	// request
	res, err := api.client.R().Get(link)
	if err != nil {
		return nil, err
	}
	if res.StatusCode() != 200 {
		return nil, fmt.Errorf("status: %d", res.StatusCode())
	}

	// json decode
	respValue := resultGetBlockTransactions{}
	err = json.Unmarshal(res.Body(), &respValue)
	if err != nil {
		return nil, err
	}
	// process result
	bz, _ := json.Marshal(respValue)
	if err != nil {
		return nil, err
	}

	result := []string{fmt.Sprintf("url: %s", link)}
	result = append(result, compareJSON(bz, res.Body())...)
	return result, nil
}

///////////////

type resultGetEvmContracts struct {
	Ok     bool `json:"ok"`
	Result struct {
		Count        uint64 `json:"count"`
		EvmContracts []struct {
			CreatedAt                    string      `json:"createdAt"`
			UpdatedAt                    string      `json:"updatedAt"`
			Address                      string      `json:"address"`
			Status                       string      `json:"status"`
			Abi                          interface{} `json:"abi"`
			ByteCode                     string      `json:"byteCode"`
			DeploymentEvmAccountAddress  string      `json:"deploymentEvmAccountAddress"`
			DeploymentEvmBlockHeight     uint64      `json:"deploymentEvmBlockHeight"`
			DeploymentEvmTransactionHash string      `json:"deploymentEvmTransactionHash"`
			DeploymentEvmReceiptId       uint64      `json:"deploymentEvmReceiptId"`
		} `json:"evmContracts"`
	} `json:"result"`
}

// /evm-contracts
// Get evm contracts
func (api *API) VerificationGetEvmContracts(opt *OptionalParams) ([]string, error) {

	var link = "/evm-contracts"
	if opt != nil {
		link += opt.String()
	}

	// request
	res, err := api.client.R().Get(link)
	if err != nil {
		return nil, err
	}
	if res.StatusCode() != 200 {
		return nil, fmt.Errorf("status: %d", res.StatusCode())
	}

	// json decode
	respValue := resultGetEvmContracts{}
	err = json.Unmarshal(res.Body(), &respValue)
	if err != nil {
		return nil, err
	}
	// process result
	bz, _ := json.Marshal(respValue)
	if err != nil {
		return nil, err
	}

	result := []string{fmt.Sprintf("url: %s", link)}
	result = append(result, compareJSON(bz, res.Body())...)
	return result, nil
}

///////////////

type resultGetEvmTransactions struct {
	Ok     bool `json:"ok"`
	Result struct {
		Count           uint64 `json:"count"`
		EvmTransactions []struct {
			CreatedAt            string      `json:"createdAt"`
			UpdatedAt            string      `json:"updatedAt"`
			Hash                 string      `json:"hash"`
			V                    string      `json:"v"`
			R                    string      `json:"r"`
			S                    string      `json:"s"`
			Gas                  uint64      `json:"gas"`
			Type                 uint64      `json:"type"`
			Input                string      `json:"input"`
			Nonce                uint64      `json:"nonce"`
			Value                string      `json:"value"`
			ChainId              uint64      `json:"chainId"`
			GasPrice             uint64      `json:"gasPrice"`
			AccessList           interface{} `json:"accessList"`
			MaxFeePerGas         uint64      `json:"maxFeePerGas"`
			MaxPriorityFeePerGas uint64      `json:"maxPriorityFeePerGas"`
			ExtraData            interface{} `json:"extraData"`
			From                 string      `json:"from"`
			To                   string      `json:"to"`
			EvmBlockHeight       uint64      `json:"evmBlockHeight"`
		} `json:"evmTransactions"`
	} `json:"result"`
}

// /evm-transactions
// Get evm transactions
func (api *API) VerificationGetEvmTransactions(opt *OptionalParams) ([]string, error) {

	var link = "/evm-transactions"
	if opt != nil {
		link += opt.String()
	}

	// request
	res, err := api.client.R().Get(link)
	if err != nil {
		return nil, err
	}
	if res.StatusCode() != 200 {
		return nil, fmt.Errorf("status: %d", res.StatusCode())
	}

	// json decode
	respValue := resultGetEvmTransactions{}
	err = json.Unmarshal(res.Body(), &respValue)
	if err != nil {
		return nil, err
	}
	// process result
	bz, _ := json.Marshal(respValue)
	if err != nil {
		return nil, err
	}

	result := []string{fmt.Sprintf("url: %s", link)}
	result = append(result, compareJSON(bz, res.Body())...)
	return result, nil
}

///////////////

type resultGetEvmAccounts struct {
	Ok     bool `json:"ok"`
	Result struct {
		Count       uint64 `json:"count"`
		EvmAccounts []struct {
			CreatedAt                  string `json:"createdAt"`
			UpdatedAt                  string `json:"updatedAt"`
			Address                    string `json:"address"`
			CreationEvmBlockHeight     uint64 `json:"creationEvmBlockHeight"`
			CreationEvmTransactionHash string `json:"creationEvmTransactionHash"`
		} `json:"evmAccounts"`
	} `json:"result"`
}

// /evm-accounts
// Get evm accounts
func (api *API) VerificationGetEvmAccounts(opt *OptionalParams) ([]string, error) {

	var link = "/evm-accounts"
	if opt != nil {
		link += opt.String()
	}

	// request
	res, err := api.client.R().Get(link)
	if err != nil {
		return nil, err
	}
	if res.StatusCode() != 200 {
		return nil, fmt.Errorf("status: %d", res.StatusCode())
	}

	// json decode
	respValue := resultGetEvmAccounts{}
	err = json.Unmarshal(res.Body(), &respValue)
	if err != nil {
		return nil, err
	}
	// process result
	bz, _ := json.Marshal(respValue)
	if err != nil {
		return nil, err
	}

	result := []string{fmt.Sprintf("url: %s", link)}
	result = append(result, compareJSON(bz, res.Body())...)
	return result, nil
}

///////////////

type resultGetEvmContract struct {
	Ok     bool `json:"ok"`
	Result struct {
		CreatedAt                    string      `json:"createdAt"`
		UpdatedAt                    string      `json:"updatedAt"`
		Address                      string      `json:"address"`
		Status                       string      `json:"status"`
		Abi                          interface{} `json:"abi"`
		ByteCode                     string      `json:"byteCode"`
		DeploymentEvmAccountAddress  string      `json:"deploymentEvmAccountAddress"`
		DeploymentEvmBlockHeight     uint64      `json:"deploymentEvmBlockHeight"`
		DeploymentEvmTransactionHash string      `json:"deploymentEvmTransactionHash"`
		DeploymentEvmReceiptId       uint64      `json:"deploymentEvmReceiptId"`
	} `json:"result"`
}

// /evm-contracts/{address}
// Get evm contract by address
func (api *API) VerificationGetEvmContract(address string) ([]string, error) {

	var r = strings.NewReplacer(
		"{address}", fmt.Sprintf("%s", address),
	)
	var link = r.Replace("/evm-contracts/{address}")

	// request
	res, err := api.client.R().Get(link)
	if err != nil {
		return nil, err
	}
	if res.StatusCode() != 200 {
		return nil, fmt.Errorf("status: %d", res.StatusCode())
	}

	// json decode
	respValue := resultGetEvmContract{}
	err = json.Unmarshal(res.Body(), &respValue)
	if err != nil {
		return nil, err
	}
	// process result
	bz, _ := json.Marshal(respValue)
	if err != nil {
		return nil, err
	}

	result := []string{fmt.Sprintf("url: %s", link)}
	result = append(result, compareJSON(bz, res.Body())...)
	return result, nil
}

///////////////

type resultGetEvmTransaction struct {
	Ok     bool `json:"ok"`
	Result struct {
		CreatedAt            string      `json:"createdAt"`
		UpdatedAt            string      `json:"updatedAt"`
		Hash                 string      `json:"hash"`
		V                    string      `json:"v"`
		R                    string      `json:"r"`
		S                    string      `json:"s"`
		Gas                  uint64      `json:"gas"`
		Type                 uint64      `json:"type"`
		Input                string      `json:"input"`
		Nonce                uint64      `json:"nonce"`
		Value                string      `json:"value"`
		ChainId              uint64      `json:"chainId"`
		GasPrice             uint64      `json:"gasPrice"`
		AccessList           interface{} `json:"accessList"`
		MaxFeePerGas         uint64      `json:"maxFeePerGas"`
		MaxPriorityFeePerGas uint64      `json:"maxPriorityFeePerGas"`
		ExtraData            interface{} `json:"extraData"`
		From                 string      `json:"from"`
		To                   string      `json:"to"`
		EvmBlockHeight       uint64      `json:"evmBlockHeight"`
	} `json:"result"`
}

// /evm-transactions/{hash}
// Get evm transaction by hash
func (api *API) VerificationGetEvmTransaction(hash string) ([]string, error) {

	var r = strings.NewReplacer(
		"{hash}", fmt.Sprintf("%s", hash),
	)
	var link = r.Replace("/evm-transactions/{hash}")

	// request
	res, err := api.client.R().Get(link)
	if err != nil {
		return nil, err
	}
	if res.StatusCode() != 200 {
		return nil, fmt.Errorf("status: %d", res.StatusCode())
	}

	// json decode
	respValue := resultGetEvmTransaction{}
	err = json.Unmarshal(res.Body(), &respValue)
	if err != nil {
		return nil, err
	}
	// process result
	bz, _ := json.Marshal(respValue)
	if err != nil {
		return nil, err
	}

	result := []string{fmt.Sprintf("url: %s", link)}
	result = append(result, compareJSON(bz, res.Body())...)
	return result, nil
}

///////////////

type resultGetEvmAccount struct {
	Ok     bool `json:"ok"`
	Result struct {
		CreatedAt                  string `json:"createdAt"`
		UpdatedAt                  string `json:"updatedAt"`
		Address                    string `json:"address"`
		CreationEvmBlockHeight     uint64 `json:"creationEvmBlockHeight"`
		CreationEvmTransactionHash string `json:"creationEvmTransactionHash"`
	} `json:"result"`
}

// /evm-accounts/{address}
// Get evm account by address
func (api *API) VerificationGetEvmAccount(address string) ([]string, error) {

	var r = strings.NewReplacer(
		"{address}", fmt.Sprintf("%s", address),
	)
	var link = r.Replace("/evm-accounts/{address}")

	// request
	res, err := api.client.R().Get(link)
	if err != nil {
		return nil, err
	}
	if res.StatusCode() != 200 {
		return nil, fmt.Errorf("status: %d", res.StatusCode())
	}

	// json decode
	respValue := resultGetEvmAccount{}
	err = json.Unmarshal(res.Body(), &respValue)
	if err != nil {
		return nil, err
	}
	// process result
	bz, _ := json.Marshal(respValue)
	if err != nil {
		return nil, err
	}

	result := []string{fmt.Sprintf("url: %s", link)}
	result = append(result, compareJSON(bz, res.Body())...)
	return result, nil
}

///////////////

type resultGetEvmContractTransactions struct {
	Ok     bool `json:"ok"`
	Result struct {
		Count                   uint64 `json:"count"`
		EvmContractTransactions []struct {
			CreatedAt            string      `json:"createdAt"`
			UpdatedAt            string      `json:"updatedAt"`
			Hash                 string      `json:"hash"`
			V                    string      `json:"v"`
			R                    string      `json:"r"`
			S                    string      `json:"s"`
			Gas                  uint64      `json:"gas"`
			Type                 uint64      `json:"type"`
			Input                string      `json:"input"`
			Nonce                uint64      `json:"nonce"`
			Value                string      `json:"value"`
			ChainId              uint64      `json:"chainId"`
			GasPrice             uint64      `json:"gasPrice"`
			AccessList           interface{} `json:"accessList"`
			MaxFeePerGas         uint64      `json:"maxFeePerGas"`
			MaxPriorityFeePerGas uint64      `json:"maxPriorityFeePerGas"`
			ExtraData            interface{} `json:"extraData"`
			From                 string      `json:"from"`
			To                   string      `json:"to"`
			EvmBlockHeight       uint64      `json:"evmBlockHeight"`
		} `json:"evmContractTransactions"`
	} `json:"result"`
}

// /evm-contracts/{address}/transactions
// Get evm contract transactions
func (api *API) VerificationGetEvmContractTransactions(address string, opt *OptionalParams) ([]string, error) {

	var r = strings.NewReplacer(
		"{address}", fmt.Sprintf("%s", address),
	)
	var link = r.Replace("/evm-contracts/{address}/transactions")
	if opt != nil {
		link += opt.String()
	}

	// request
	res, err := api.client.R().Get(link)
	if err != nil {
		return nil, err
	}
	if res.StatusCode() != 200 {
		return nil, fmt.Errorf("status: %d", res.StatusCode())
	}

	// json decode
	respValue := resultGetEvmContractTransactions{}
	err = json.Unmarshal(res.Body(), &respValue)
	if err != nil {
		return nil, err
	}
	// process result
	bz, _ := json.Marshal(respValue)
	if err != nil {
		return nil, err
	}

	result := []string{fmt.Sprintf("url: %s", link)}
	result = append(result, compareJSON(bz, res.Body())...)
	return result, nil
}

///////////////

type resultGetEvmContractEvents struct {
	Ok     bool `json:"ok"`
	Result struct {
		Count             uint64 `json:"count"`
		EvmContractEvents []struct {
			CreatedAt          string      `json:"createdAt"`
			UpdatedAt          string      `json:"updatedAt"`
			Id                 uint64      `json:"id"`
			Root               string      `json:"root"`
			Type               uint64      `json:"type"`
			Status             bool        `json:"status"`
			GasUsed            uint64      `json:"gasUsed"`
			LogsBloom          string      `json:"logsBloom"`
			TransactionIndex   uint64      `json:"transactionIndex"`
			CumulativeGasUsed  uint64      `json:"cumulativeGasUsed"`
			ExtraData          interface{} `json:"extraData"`
			EvmBlockHeight     uint64      `json:"evmBlockHeight"`
			EvmTransactionHash string      `json:"evmTransactionHash"`
			ContractAddress    string      `json:"contractAddress"`
			EvmReceiptLogs     []struct {
				CreatedAt          string      `json:"createdAt"`
				UpdatedAt          string      `json:"updatedAt"`
				Id                 uint64      `json:"id"`
				Data               string      `json:"data"`
				Address            string      `json:"address"`
				Removed            bool        `json:"removed"`
				LogIndex           uint64      `json:"logIndex"`
				ExtraData          interface{} `json:"extraData"`
				EvmBlockHeight     uint64      `json:"evmBlockHeight"`
				EvmTransactionHash string      `json:"evmTransactionHash"`
				EvmReceiptId       uint64      `json:"evmReceiptId"`
				Topics             []string    `json:"topics"`
			} `json:"evmReceiptLogs"`
			EvmTransaction struct {
				CreatedAt            string      `json:"createdAt"`
				UpdatedAt            string      `json:"updatedAt"`
				Hash                 string      `json:"hash"`
				V                    string      `json:"v"`
				R                    string      `json:"r"`
				S                    string      `json:"s"`
				Gas                  uint64      `json:"gas"`
				Type                 uint64      `json:"type"`
				Input                string      `json:"input"`
				Nonce                uint64      `json:"nonce"`
				Value                string      `json:"value"`
				ChainId              uint64      `json:"chainId"`
				GasPrice             uint64      `json:"gasPrice"`
				AccessList           interface{} `json:"accessList"`
				MaxFeePerGas         uint64      `json:"maxFeePerGas"`
				MaxPriorityFeePerGas uint64      `json:"maxPriorityFeePerGas"`
				ExtraData            interface{} `json:"extraData"`
				From                 string      `json:"from"`
				To                   string      `json:"to"`
				EvmBlockHeight       uint64      `json:"evmBlockHeight"`
			} `json:"evmTransaction"`
		} `json:"evmContractEvents"`
	} `json:"result"`
}

// /evm-contracts/{address}/events
// Get evm contract events
func (api *API) VerificationGetEvmContractEvents(address string, opt *OptionalParams) ([]string, error) {

	var r = strings.NewReplacer(
		"{address}", fmt.Sprintf("%s", address),
	)
	var link = r.Replace("/evm-contracts/{address}/events")
	if opt != nil {
		link += opt.String()
	}

	// request
	res, err := api.client.R().Get(link)
	if err != nil {
		return nil, err
	}
	if res.StatusCode() != 200 {
		return nil, fmt.Errorf("status: %d", res.StatusCode())
	}

	// json decode
	respValue := resultGetEvmContractEvents{}
	err = json.Unmarshal(res.Body(), &respValue)
	if err != nil {
		return nil, err
	}
	// process result
	bz, _ := json.Marshal(respValue)
	if err != nil {
		return nil, err
	}

	result := []string{fmt.Sprintf("url: %s", link)}
	result = append(result, compareJSON(bz, res.Body())...)
	return result, nil
}

///////////////

type resultGetEvmAccountBalances struct {
	Ok     bool `json:"ok"`
	Result struct {
		Count                  uint64 `json:"count"`
		EvmTokenAccountBalance []struct {
			Address                      string `json:"address"`
			CosmosAccountAddress         string `json:"cosmosAccountAddress"`
			CreationEvmBlockHeight       uint64 `json:"creationEvmBlockHeight"`
			CreationEvmTransactionHash   string `json:"creationEvmTransactionHash"`
			EvmAccountERC20TokenBalances []struct {
				EvmTokenAddress   string `json:"evmTokenAddress"`
				EvmAccountAddress string `json:"evmAccountAddress"`
				Amount            string `json:"amount"`
				EvmToken          struct {
					Address            string `json:"address"`
					Symbol             string `json:"symbol"`
					Title              string `json:"title"`
					Decimals           uint64 `json:"decimals"`
					TotalSupply        uint64 `json:"totalSupply"`
					EvmContractAddress string `json:"evmContractAddress"`
					EvmTokenTypeName   string `json:"evmTokenTypeName"`
					EvmContract        struct {
						CreatedAt                    string      `json:"createdAt"`
						UpdatedAt                    string      `json:"updatedAt"`
						Address                      string      `json:"address"`
						Status                       string      `json:"status"`
						Abi                          interface{} `json:"abi"`
						ByteCode                     string      `json:"byteCode"`
						DeploymentEvmAccountAddress  string      `json:"deploymentEvmAccountAddress"`
						DeploymentEvmBlockHeight     uint64      `json:"deploymentEvmBlockHeight"`
						DeploymentEvmTransactionHash string      `json:"deploymentEvmTransactionHash"`
						DeploymentEvmReceiptId       uint64      `json:"deploymentEvmReceiptId"`
					} `json:"evmContract"`
				} `json:"evmToken"`
			} `json:"evmAccountERC20TokenBalances"`
			EvmAccountERC721TokenBalance []struct {
				EvmTokenAddress   string `json:"evmTokenAddress"`
				EvmAccountAddress string `json:"evmAccountAddress"`
				Amount            string `json:"amount"`
				EvmToken          struct {
					Address            string `json:"address"`
					Symbol             string `json:"symbol"`
					Title              string `json:"title"`
					Decimals           uint64 `json:"decimals"`
					TotalSupply        uint64 `json:"totalSupply"`
					EvmContractAddress string `json:"evmContractAddress"`
					EvmTokenTypeName   string `json:"evmTokenTypeName"`
					EvmContract        struct {
						CreatedAt                    string      `json:"createdAt"`
						UpdatedAt                    string      `json:"updatedAt"`
						Address                      string      `json:"address"`
						Status                       string      `json:"status"`
						Abi                          interface{} `json:"abi"`
						ByteCode                     string      `json:"byteCode"`
						DeploymentEvmAccountAddress  string      `json:"deploymentEvmAccountAddress"`
						DeploymentEvmBlockHeight     uint64      `json:"deploymentEvmBlockHeight"`
						DeploymentEvmTransactionHash string      `json:"deploymentEvmTransactionHash"`
						DeploymentEvmReceiptId       uint64      `json:"deploymentEvmReceiptId"`
					} `json:"evmContract"`
				} `json:"evmToken"`
			} `json:"evmAccountERC721TokenBalance"`
			EvmAccountERC1155TokenBalance []struct {
				EvmTokenAddress   string `json:"evmTokenAddress"`
				EvmAccountAddress string `json:"evmAccountAddress"`
				Amount            string `json:"amount"`
				EvmToken          struct {
					Address            string `json:"address"`
					Symbol             string `json:"symbol"`
					Title              string `json:"title"`
					Decimals           uint64 `json:"decimals"`
					TotalSupply        uint64 `json:"totalSupply"`
					EvmContractAddress string `json:"evmContractAddress"`
					EvmTokenTypeName   string `json:"evmTokenTypeName"`
					EvmContract        struct {
						CreatedAt                    string      `json:"createdAt"`
						UpdatedAt                    string      `json:"updatedAt"`
						Address                      string      `json:"address"`
						Status                       string      `json:"status"`
						Abi                          interface{} `json:"abi"`
						ByteCode                     string      `json:"byteCode"`
						DeploymentEvmAccountAddress  string      `json:"deploymentEvmAccountAddress"`
						DeploymentEvmBlockHeight     uint64      `json:"deploymentEvmBlockHeight"`
						DeploymentEvmTransactionHash string      `json:"deploymentEvmTransactionHash"`
						DeploymentEvmReceiptId       uint64      `json:"deploymentEvmReceiptId"`
					} `json:"evmContract"`
				} `json:"evmToken"`
			} `json:"evmAccountERC1155TokenBalance"`
		} `json:"evmTokenAccountBalance"`
	} `json:"result"`
}

// /evm-accounts/{address}/balances
// Get evm contract events
func (api *API) VerificationGetEvmAccountBalances(address string, opt *OptionalParams) ([]string, error) {

	var r = strings.NewReplacer(
		"{address}", fmt.Sprintf("%s", address),
	)
	var link = r.Replace("/evm-accounts/{address}/balances")
	if opt != nil {
		link += opt.String()
	}

	// request
	res, err := api.client.R().Get(link)
	if err != nil {
		return nil, err
	}
	if res.StatusCode() != 200 {
		return nil, fmt.Errorf("status: %d", res.StatusCode())
	}

	// json decode
	respValue := resultGetEvmAccountBalances{}
	err = json.Unmarshal(res.Body(), &respValue)
	if err != nil {
		return nil, err
	}
	// process result
	bz, _ := json.Marshal(respValue)
	if err != nil {
		return nil, err
	}

	result := []string{fmt.Sprintf("url: %s", link)}
	result = append(result, compareJSON(bz, res.Body())...)
	return result, nil
}

///////////////

type resultGetValidatorsByKind struct {
	Ok     bool `json:"ok"`
	Result struct {
		Count      int64 `json:"count"`
		Online     int64 `json:"online"`
		Validators []struct {
			Address string `json:"address"`
			BlockId int64  `json:"blockId"`
		} `json:"validators"`
		FreeSlots int64 `json:"freeSlots"`
	} `json:"result"`
}

// /validators/{kind}
// Default route
func (api *API) VerificationGetValidatorsByKind(kind string) ([]string, error) {

	var r = strings.NewReplacer(
		"{kind}", fmt.Sprintf("%s", kind),
	)
	var link = r.Replace("/validators/{kind}")

	// request
	res, err := api.client.R().Get(link)
	if err != nil {
		return nil, err
	}
	if res.StatusCode() != 200 {
		return nil, fmt.Errorf("status: %d", res.StatusCode())
	}

	// json decode
	respValue := resultGetValidatorsByKind{}
	err = json.Unmarshal(res.Body(), &respValue)
	if err != nil {
		return nil, err
	}
	// process result
	bz, _ := json.Marshal(respValue)
	if err != nil {
		return nil, err
	}

	result := []string{fmt.Sprintf("url: %s", link)}
	result = append(result, compareJSON(bz, res.Body())...)
	return result, nil
}

///////////////

type resultGetValidatorsCoins struct {
	Ok     bool `json:"ok"`
	Result []struct {
		Count  uint64 `json:"count"`
		Stakes struct {
			Address string `json:"address"`
			Coins   []struct {
				CoinSymbol string `json:"coinSymbol"`
				Amount     string `json:"amount"`
				BaseAmount string `json:"baseAmount"`
				Avatar     string `json:"avatar"`
			} `json:"coins"`
		} `json:"stakes"`
	} `json:"result"`
}

// /validators/{address}/coins
// Get coins grouped by delegator account address
func (api *API) VerificationGetValidatorsCoins(address string, opt *OptionalParams) ([]string, error) {

	var r = strings.NewReplacer(
		"{address}", fmt.Sprintf("%s", address),
	)
	var link = r.Replace("/validators/{address}/coins")
	if opt != nil {
		link += opt.String()
	}

	// request
	res, err := api.client.R().Get(link)
	if err != nil {
		return nil, err
	}
	if res.StatusCode() != 200 {
		return nil, fmt.Errorf("status: %d", res.StatusCode())
	}

	// json decode
	respValue := resultGetValidatorsCoins{}
	err = json.Unmarshal(res.Body(), &respValue)
	if err != nil {
		return nil, err
	}
	// process result
	bz, _ := json.Marshal(respValue)
	if err != nil {
		return nil, err
	}

	result := []string{fmt.Sprintf("url: %s", link)}
	result = append(result, compareJSON(bz, res.Body())...)
	return result, nil
}

///////////////

type resultGetValidator struct {
	Ok     bool `json:"ok"`
	Result struct {
		Address string `json:"address"`
		BlockId int64  `json:"blockId"`
	} `json:"result"`
}

// /validator/{address}
// Get validator by address (public key)
func (api *API) VerificationGetValidator(address string) ([]string, error) {

	var r = strings.NewReplacer(
		"{address}", fmt.Sprintf("%s", address),
	)
	var link = r.Replace("/validator/{address}")

	// request
	res, err := api.client.R().Get(link)
	if err != nil {
		return nil, err
	}
	if res.StatusCode() != 200 {
		return nil, fmt.Errorf("status: %d", res.StatusCode())
	}

	// json decode
	respValue := resultGetValidator{}
	err = json.Unmarshal(res.Body(), &respValue)
	if err != nil {
		return nil, err
	}
	// process result
	bz, _ := json.Marshal(respValue)
	if err != nil {
		return nil, err
	}

	result := []string{fmt.Sprintf("url: %s", link)}
	result = append(result, compareJSON(bz, res.Body())...)
	return result, nil
}

///////////////

type resultGetValidatorStakes struct {
	Ok     bool `json:"ok"`
	Result struct {
		Count  int64 `json:"count"`
		Stakes []struct {
			CreatedAt   string `json:"createdAt"`
			UpdatedAt   string `json:"updatedAt"`
			CoinSymbol  string `json:"coinSymbol"`
			Amount      string `json:"amount"`
			AddressId   string `json:"addressId"`
			ValidatorId string `json:"validatorId"`
		} `json:"stakes"`
	} `json:"result"`
}

// /validator/{address}/stakes
// Get validator's stake
func (api *API) VerificationGetValidatorStakes(address string, opt *OptionalParams) ([]string, error) {

	var r = strings.NewReplacer(
		"{address}", fmt.Sprintf("%s", address),
	)
	var link = r.Replace("/validator/{address}/stakes")
	if opt != nil {
		link += opt.String()
	}

	// request
	res, err := api.client.R().Get(link)
	if err != nil {
		return nil, err
	}
	if res.StatusCode() != 200 {
		return nil, fmt.Errorf("status: %d", res.StatusCode())
	}

	// json decode
	respValue := resultGetValidatorStakes{}
	err = json.Unmarshal(res.Body(), &respValue)
	if err != nil {
		return nil, err
	}
	// process result
	bz, _ := json.Marshal(respValue)
	if err != nil {
		return nil, err
	}

	result := []string{fmt.Sprintf("url: %s", link)}
	result = append(result, compareJSON(bz, res.Body())...)
	return result, nil
}

///////////////

type resultGetValidatorStakesNFT struct {
	Ok     bool `json:"ok"`
	Result struct {
		Count  int64 `json:"count"`
		Stakes []struct {
			CreatedAt   string `json:"createdAt"`
			UpdatedAt   string `json:"updatedAt"`
			CoinSymbol  string `json:"coinSymbol"`
			Amount      string `json:"amount"`
			AddressId   string `json:"addressId"`
			ValidatorId string `json:"validatorId"`
		} `json:"stakes"`
	} `json:"result"`
}

// /validator/{address}/stakes/nfts
// Get validator's NFTs stake
func (api *API) VerificationGetValidatorStakesNFT(address string) ([]string, error) {

	var r = strings.NewReplacer(
		"{address}", fmt.Sprintf("%s", address),
	)
	var link = r.Replace("/validator/{address}/stakes/nfts")

	// request
	res, err := api.client.R().Get(link)
	if err != nil {
		return nil, err
	}
	if res.StatusCode() != 200 {
		return nil, fmt.Errorf("status: %d", res.StatusCode())
	}

	// json decode
	respValue := resultGetValidatorStakesNFT{}
	err = json.Unmarshal(res.Body(), &respValue)
	if err != nil {
		return nil, err
	}
	// process result
	bz, _ := json.Marshal(respValue)
	if err != nil {
		return nil, err
	}

	result := []string{fmt.Sprintf("url: %s", link)}
	result = append(result, compareJSON(bz, res.Body())...)
	return result, nil
}
